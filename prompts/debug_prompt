你将扮演一位经验丰富的软件工程师。
你的代码质量很高，可读性强，易于维护，遵循了良好的代码规范，有详细的注释（主要以中文书写）。
你的代码有很高的鲁棒性，充分考虑到了可能遇到的各种异常情况并对每种情况都做了处理，包括但不限于空指针、数组越界、类型转换错误、IO异常等。
你的代码在性能方面也有良好的表现，能够高效地处理大量数据。
你的代码在各个关键步骤上都有日志输出，以便在出现问题时能够快速定位问题。

你正在编写代码以达到这个目的：

[[[
参考这个方法，编写另一个与之类似的方法，但输出是字母与数字共同编码。注意，并不是0-9这十个数字和所有的26个字母都参与编码，因为有些数字与字母在外观上接近导致容易被辨识错误，需要剔除掉那些容易辨识错误的字母和数字。
然后编写一个测试方法用以测试你的代码，注意测试用例需要充分考虑到边缘情况。

参考的代码：
def decimal_to_base26(n):
"""将十进制数字转换为26进制字母表示"""
result = ""
while n > 0:
n, remainder = divmod(n - 1, 26)
result = chr(remainder + ord('a')) + result
return result
]]]

你刚刚编写的代码运行似乎出现了一些问题，找出并修复它。

运行的代码（基础代码）是：

[[[
def decimal_to_mixed_base22(n):
    """将十进制数字转换为22进制字母数字混合表示，排除了易混淆的字符'I', 'O', 'l', '1'"""
    allowed_chars = "0123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz"
    result = ""
    while n > 0:
        n, remainder = divmod(n, 22)
        result = allowed_chars[remainder] + result
    return result

def test_decimal_to_mixed_base22():
    print("测试正常数值:")
    print(f"0 -> {decimal_to_mixed_base22(0)}")  # 应当输出 "0"
    print(f"21 -> {decimal_to_mixed_base22(21)}")  # 应当输出 "T"
    print(f"22 -> {decimal_to_mixed_base22(22)}")  # 应当输出 "10"
    print(f"45 -> {decimal_to_mixed_base22(45)}")  # 应当输出 "21"
    
    print("\n测试大数值:")
    print(f"1000 -> {decimal_to_mixed_base22(1000)}")  # 应当输出 "1F6"
    print(f"2222 -> {decimal_to_mixed_base22(2222)}")  # 用于检验边界处理，实际输出会是22进制表示
    
    print("\n测试边缘情况:")
    try:
        print(f"-1 -> {decimal_to_mixed_base22(-1)}")  # 应当不抛出异常，但需考虑如何处理负数
    except ValueError as e:
        print(f"处理负数时捕获到的错误: {e}")
    
    print("测试完成。")

# 运行测试
test_decimal_to_mixed_base22()
]]]

输出是：

[[[
测试正常数值:
0 -> 
21 -> M
22 -> 10
45 -> 21

测试大数值:
1000 -> 21A
2222 -> 4D0

测试边缘情况:
-1 -> 
测试完成。
]]]

请根据输出仔细思考，为什么输出没有符合预期，上面那段代码中为什么会出现问题，试着从逻辑上分析并给出可能的原因。

给出一个修复问题的建议，并修复代码。注意，修复问题时，只需要在上面代码的基础上做尽量少的修改来解决问题，对于可以不用修改的部分不进行修改。
不要试图删除基础代码中的注释和用于调试的日志输出，除非这是必要的。
最后，给我展示修改后用于替换基础代码的完整代码（最终代码），包括修改了的部分和未修改的部分。
给我的最终代码应当是完整可运行的。
最终代码不应该包含任何省略或指向性注释。
不应该包含类似于“...省略实现”、“...保持不变”、“与...相同”这样的注释来代替实际代码。