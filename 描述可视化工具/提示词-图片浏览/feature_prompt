你是一位经验丰富的软件工程师。
你的代码质量很高，可读性强，易于维护，遵循了良好的代码规范，有详细的注释（主要以中文书写）。
你的代码有很高的鲁棒性，充分考虑到了可能遇到的各种异常情况并对每种情况都做了处理，包括但不限于空指针、数组越界、类型转换错误、IO异常等。
你的代码在性能方面也有良好的表现，能够高效地处理大量数据。

你将根据我提出的需求，编写一段代码，并确保这段代码符合上述要求。

这是需求，包括过往历次迭代的需求记录：
[[[
初始需求：((
编写一个基于insightface的面部裁剪工具。传入一个列表，遍历目列表中的图片文件路径，识别出图片中的人脸，并将每个人脸裁剪到一张新图片中保存到磁盘上。
insightface相关的参考代码：
[[
import cv2
import numpy as np
import insightface
from insightface.app import FaceAnalysis
from insightface.data import get_image as ins_get_image

app = FaceAnalysis(providers=['CUDAExecutionProvider', 'CPUExecutionProvider'])
app.prepare(ctx_id=0, det_size=(640, 640))
img = ins_get_image('t1')
faces = app.get(img)
rimg = app.draw_on(img, faces)
cv2.imwrite("./t1_output.jpg", rimg)
]]
维护一个从0开始的计数器，输出图片时，文件名为该计数器的自定义编码值，自定义编码方法如下：
[[
    def decimal_to_custom_base(n):
        """将十进制数字转换为使用自定义非混淆字符集的基25字符串。"""
        characters = 'acdefhjkmnpqrtuvwxyz23478'
        base = len(characters)
        if n == 0:
            return characters[0]
        result = ""
        while n > 0:
            n, remainder = divmod(n, base)
            result = characters[remainder] + result
        return result
]]
需传入一个目标目录，在目录下创建一个叫faces的目录，如果存在则删除重建。范例：
[[
    target_dir = Path(directory)
    thumbnail_dir = target_dir / "thumbnail"
    mapping_file_path = target_dir / "mapping.txt"

    if not target_dir.is_dir():
        tqdm.write(f"目录不存在: {directory}")
        return

    if thumbnail_dir.exists():
        tqdm.write(f"删除已存在的缩略图目录: {thumbnail_dir}")
        shutil.rmtree(thumbnail_dir, onerror=handle_remove_readonly)
    thumbnail_dir.mkdir(parents=True, exist_ok=True)
]]
对于每一个输出的图片文件，创建一个同名的文本文件记录其人脸的信息（app.get返回的该张人脸的信息）
使用一个列表记录每个输出图片与原始图片的对应关系，列表项为字符串，格式为：“输出图片文件名不包含扩展名*原始图片路径”
任务完成时将这个列表序列化到文本文件里，文本文件名称为"face_mapping.txt"，保存到目标目录下。如果这个文件已存在，则删除重新创建。

输出人脸图片时，裁剪范围要比app.get返回的人脸框大20%，以保证人脸完整。但裁剪范围不得超出原始图片范围。

用一个tqdm的进度条来表示整个列表的处理情况。
))
迭代需求1(此次你需要实现的)：((
一、增加代码，用于产生传入的图片列表，逻辑是：
(
1、读取一个文本文件A来获取一个图片名称的列表，A的格式类似于：
Unique Images:
qw.jpg
xd.jpg
k2.jpg
xk.jpg

Similar Groups:
Group:
hq.jpg
h4.jpg

Group:
hr.jpg
h7.jpg

Group:
hv.jpg
je.jpg
你只需要获得所有的Unique Images。

2、A所在的目录下有一个‘thumbnail’目录，刚刚获取的unique images即是这个目录下的文件。也是要传入原来代码逻辑的图片文件列表。
)
二、修改裁剪图片的逻辑，原来检测传入的图片中人脸，并从传入的图片中裁剪。现在改为：检测及获取人脸信息逻辑不变，但从另一个传入图片对应的原始高清大图中裁剪。
基于性能考虑，用于检测的图片均为从原始高清大图获取的灰度缩略图，缩略图和原始图片的对应关系这样获取：
(
上面提到的文本文件A所在的目录下有文本文件mapping.txt，格式类似于：
/Volumes/192.168.1.173-1/pic/陈都灵_503[167_MB]/陈都灵黑白魅力写真大片/2.jpg*c
/Volumes/192.168.1.173-1/pic/陈都灵_503[167_MB]/陈都灵黑白魅力写真大片/6.jpg*d
/Volumes/192.168.1.173-1/pic/陈都灵_503[167_MB]/陈都灵黑白魅力写真大片/1.jpg*e
其中*号前为原始图片路径，*号后为缩略图文件名。
)
你需要在用缩略图检测到人脸并获得人脸信息后，查找到缩略图对应的原始图片，打开来裁剪出用于输出的人脸图片。
需要注意的是，缩略图和原始图片的尺寸关系存在一个转换，会影响到裁剪矩形的计算，可以参考生产缩略图的代码：
(
    img = Image.open(source_path)
    img = rotate_image_according_to_exif(img)
    if grayscale:
        img = img.convert('L')
    # 保持宽高比缩放
    img.thumbnail((thumbnail_size, thumbnail_size), Image.LANCZOS)
    # 创建一个白色背景的新图片
    final_image = Image.new('RGB' if not grayscale else 'L', (thumbnail_size, thumbnail_size), 'white')
    # 计算居中的起始坐标
    x = (final_image.width - img.width) // 2
    y = (final_image.height - img.height) // 2
    # 将img贴在final_image的计算位置上
    final_image.paste(img, (x, y))
    final_image.save(target_path, format='JPEG', quality=85)
)
三、原来代码里face_mapping.txt保存的是用于检测的缩略图与输出的人脸图之间的关系，现在要改为原始图片与人脸图片之间的关系。
四、原来代码中需要传入main的directory，就是A所在的目录。
))

]]]

这是目前已实现的代码：
[[[
# 迭代编号：1
import os
import errno
import stat
import cv2
import numpy as np
import shutil
import insightface
from insightface.app import FaceAnalysis
from tqdm import tqdm
from pathlib import Path

def handle_remove_readonly(func, path, exc):
    """移除只读文件的异常处理函数。"""
    excvalue = exc[1]
    if func in (os.rmdir, os.unlink) and excvalue.errno == errno.EACCES:
        os.chmod(path, stat.S_IRWXU)
        func(path)
    else:
        raise

def decimal_to_custom_base(n):
    """将十进制数字转换为使用自定义非混淆字符集的基25字符串。"""
    characters = 'acdefhjkmnpqrtuvwxyz23478'
    base = len(characters)
    if n == 0:
        return characters[0]
    result = ""
    while n > 0:
        n, remainder = divmod(n, base)
        result = characters[remainder] + result
    return result

def prepare_directory(directory):
    """准备输出目录，确保目录存在且干净。"""
    target_dir = Path(directory)
    faces_dir = target_dir / "faces"
    mapping_file_path = target_dir / "face_mapping.txt"

    if not target_dir.is_dir():
        tqdm.write(f"目录不存在: {directory}")
        return None, None

    if faces_dir.exists():
        tqdm.write(f"删除已存在的人脸图片目录: {faces_dir}")
        shutil.rmtree(faces_dir, onerror=handle_remove_readonly)
    faces_dir.mkdir(parents=True, exist_ok=True)

    if mapping_file_path.exists():
        tqdm.write(f"删除已存在的映射文件: {mapping_file_path}")
        mapping_file_path.unlink()

    return faces_dir, mapping_file_path

def process_images(image_paths, output_dir):
    """处理图像列表中的每个图像，识别人脸并保存裁剪的人脸图像。"""
    app = FaceAnalysis(providers=['CUDAExecutionProvider', 'CPUExecutionProvider'])
    app.prepare(ctx_id=0, det_size=(640, 640))
    face_mappings = []
    expand_range = 0.2
    for index, img_path in enumerate(tqdm(image_paths, desc="处理图片")):
        img = cv2.imread(str(img_path))
        faces = app.get(img)
        for face_id, face in enumerate(faces):
            bbox = face.bbox.astype(int)
            x, y, x2, y2 = bbox
            w, h = x2 - x, y2 - y
            x, y = max(0, x - int(expand_range * 0.5 * w)), max(0, y - int(expand_range * 0.5 * h))
            x2, y2 = min(img.shape[1], x2 + int(expand_range * 0.5 * w)), min(img.shape[0], y2 + int(expand_range * 0.5 * h))
            cropped_face = img[y:y2, x:x2]
            face_filename = decimal_to_custom_base(index * 100 + face_id) + ".jpg"
            cv2.imwrite(str(output_dir / face_filename), cropped_face)
            with open(str(output_dir / (face_filename[:-4] + ".txt")), 'w') as f:
                f.write(str(face))
            face_mappings.append(f"{face_filename[:-4]}*{img_path}")
    return face_mappings

def save_mappings(mapping_file_path, mappings):
    """保存映射到文件。"""
    with open(mapping_file_path, 'w') as f:
        for mapping in mappings:
            f.write(mapping + "\n")

def main(directory, image_paths):
    """主函数，负责整个处理流程。"""
    output_dir, mapping_file_path = prepare_directory(directory)
    if output_dir is None:
        return
    mappings = process_images(image_paths, output_dir)
    save_mappings(mapping_file_path, mappings)
]]]

修改代码过程中严格遵守以下几条规则：
1、禁止修改任何和新增需求无关的部分！
2、所有的方法(method)需要添加详细的注释，包括方法功能，参数、返回值的解释。
3、每一句代码都需要有注释，以提高代码的可读性。
4、输出尽量多的日志，以使调试过程中能获取更多的状态信息，提高调试效率。
5、禁止移除旧代码中的功能，除非这是上文中“此次修改的新需求”里明确要求的。
6、禁止删除旧代码中被注释掉的代码。

对于迭代编号的标注；
1、旧代码的迭代编号见代码第一行。
2、此次修改的迭代编号在旧代码中的迭代编号上加1。修改后的代码的第一行显示此次修改的迭代编号。
3、此次迭代做出的每一处代码改动都需要用注释标注，标明此次修改的迭代编号。格式为：(改动描述) 迭代编号：(此次改动的迭代编号)。
4、如果旧代码中有包含迭代编号的注释（非此次迭代编号），删除掉迭代编号，保留对代码解释的部分。

最后，展示修改后用于的完整代码，完整代码应该严格满足以下要求：
1、是可运行的。
2、包含此次修改的部分和未修改的部分。
3、不包含任何省略或指向性注释。
4、不应该包含类似于“...省略实现”、“...保持不变”、“与...相同”这样的注释来代替实际代码。